<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crystal Match Pro</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <link rel="preload" href="assets/sounds/explode.mp3" as="audio">
    <style>
        :root { --bg: linear-gradient(135deg, #667eea 0%, #764ba2 100%); --cell: 45px; --gem: 35px; }
        * { margin:0; padding:0; box-sizing:border-box; user-select:none; }
        body { background: var(--bg); color:white; font-family:'Arial',sans-serif; overflow:hidden; height:100vh; }

        /* === LOADER === */
        #loader { position:fixed; top:0; left:0; width:100%; height:100%; background:var(--bg); z-index:9999; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:20px; transition:opacity .6s; }
        .logo { width:80px; height:80px; background:radial-gradient(circle, #FFD166, #FF6B6B); border-radius:50%; box-shadow:0 0 30px rgba(255,215,102,.8); animation:pulse 1.5s infinite; }
        .loader-text { font-size:18px; font-weight:bold; background:linear-gradient(90deg,#FFD166,#FF6B6B); -webkit-background-clip:text; -webkit-text-fill-color:transparent; }
        .loader-bar { width:200px; height:4px; background:rgba(255,255,255,.2); border-radius:2px; overflow:hidden; }
        .loader-fill { width:0%; height:100%; background:linear-gradient(90deg,#FFD166,#FF6B6B); border-radius:2px; transition:width .3s; }

        .container { display:none; flex-direction:column; align-items:center; padding:10px; height:100%; }
        .header { display:flex; justify-content:space-between; width:100%; max-width:500px; margin-bottom:10px; background:rgba(255,255,255,.1); backdrop-filter:blur(10px); border-radius:20px; padding:15px; box-shadow:0 8px 32px rgba(0,0,0,.3); }
        .stats { display:flex; flex-direction:column; gap:5px; }
        .stat-item { display:flex; align-items:center; gap:8px; font-size:14px; font-weight:bold; }
        .stat-value { background:rgba(255,255,255,.2); padding:4px 12px; border-radius:15px; min-width:60px; text-align:center; }

        #game-board { display:grid; grid-template-columns:repeat(8,1fr); gap:4px; background:rgba(0,0,0,.3); border-radius:15px; padding:8px; }
        .cell { width:var(--cell); height:var(--cell); background:rgba(255,255,255,.1); border-radius:12px; display:flex; align-items:center; justify-content:center; cursor:pointer; position:relative; overflow:hidden; }
        .gem { width:var(--gem); height:var(--gem); border-radius:10px; box-shadow:0 4px 15px rgba(0,0,0,.3); transition:all .3s; position:relative; }
        .gem::after { content:''; position:absolute; top:2px; left:2px; right:2px; bottom:2px; background:linear-gradient(135deg,rgba(255,255,255,.4),transparent); border-radius:8px; }
        .gem.selected { transform:scale(1.2); box-shadow:0 0 25px gold; z-index:10; }

        /* === СПЕЦКРИСТАЛЛЫ === */
        .gem-bomb { background:radial-gradient(circle, #FF3B3B, #FF8E8E); }
        .gem-rainbow { background:conic-gradient(#FF6B6B, #4ECDC4, #FFD166, #06D6A0, #118AB2, #9B5DE5, #F15BB5); animation:spin 2s linear infinite; }
        .gem-lightning { background:linear-gradient(135deg, #FFD700, #FFA500); box-shadow:0 0 20px gold; }

        @keyframes spin { to { transform:rotate(360deg); } }
        @keyframes pulse { 0%,100% { transform:scale(1); } 50% { transform:scale(1.1); } }
        @keyframes explode { to { transform:scale(0); opacity:0; } }
        @keyframes fall { from { transform:translateY(-150px); opacity:0; } to { transform:translateY(0); opacity:1; } }
        @keyframes spawn { 0% { transform:scale(0) rotate(-180deg); } 70% { transform:scale(1.1); } 100% { transform:scale(1); } }

        .gem.exploding { animation:explode .5s ease-out forwards; }
        .gem.falling { animation:fall .5s ease-in; }
        .gem.spawning { animation:spawn .5s ease-out; }

        .controls { display:flex; gap:15px; margin-top:15px; }
        .btn { padding:12px 25px; border:none; border-radius:20px; font-weight:bold; cursor:pointer; transition:all .3s; }
        .btn:hover { transform:translateY(-2px); }
        .btn-primary { background:linear-gradient(135deg,#FF6B6B,#FF8E8E); color:white; box-shadow:0 8px 20px rgba(255,107,107,.4); }
        .btn-premium { background:linear-gradient(135deg,#FFD166,#FFE8A3); color:#333; box-shadow:0 8px 20px rgba(255,209,102,.4); }

        .progress-bar { height:12px; background:linear-gradient(90deg,#FF6B6B,#4ECDC4,#118AB2); border-radius:10px; width:0%; transition:width .5s; }

        .modal { position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.8); display:flex; align-items:center; justify-content:center; z-index:1000; backdrop-filter:blur(10px); }
        .modal-content { background:var(--bg); padding:30px; border-radius:25px; text-align:center; max-width:90%; box-shadow:0 25px 50px rgba(0,0,0,.5); animation:modal-appear .5s; }
        @keyframes modal-appear { from { transform:scale(.7) translateY(50px); opacity:0; } to { transform:scale(1); opacity:1; } }

        .leaderboard { margin-top:20px; }
        .lb-item { display:flex; justify-content:space-between; padding:8px 12px; background:rgba(255,255,255,.1); border-radius:10px; margin:4px 0; }

        @media (max-width:500px) { :root { --cell:35px; --gem:28px; } .btn { padding:10px 20px; font-size:14px; } }
        .hidden { display:none !important; }
    </style>
</head>
<body>

<!-- LOADER -->
<div id="loader">
    <div class="logo"></div>
    <div class="loader-text">CRYSTAL MATCH PRO</div>
    <div class="loader-bar"><div class="loader-fill" id="loader-fill"></div></div>
</div>

<!-- GAME -->
<div class="container" id="game-container">
    <div class="header">
        <div class="stats">
            <div class="stat-item">Очки: <div class="stat-value" id="score">0</div></div>
            <div class="stat-item">Ходы: <div class="stat-value" id="moves">25</div></div>
            <div class="stat-item">Уровень: <div class="stat-value" id="level">1</div></div>
        </div>
        <div class="stats">
            <div class="stat-item">Цель: <div class="stat-value" id="target">1000</div></div>
            <div class="stat-item">Комбо: <div class="stat-value" id="combo">x1</div></div>
        </div>
    </div>

    <div style="background:rgba(255,255,255,.05); border-radius:25px; padding:15px; box-shadow:0 20px 40px rgba(0,0,0,.4); backdrop-filter:blur(15px);">
        <div id="game-board"></div>
    </div>

    <div style="width:100%; max-width:500px; margin:15px 0; background:rgba(255,255,255,.1); border-radius:15px; padding:8px;">
        <div class="progress-bar" id="progress-bar"></div>
    </div>

    <div class="controls">
        <button class="btn btn-primary" id="hint-btn">Подсказка</button>
        <button class="btn btn-premium" id="premium-btn">ПРЕМИУМ</button>
        <button class="btn btn-primary" id="leaderboard-btn">Лидеры</button>
        <button class="btn btn-primary" id="restart-btn">Заново</button>
    </div>
</div>

<!-- WIN MODAL -->
<div id="win-modal" class="modal hidden">
    <div class="modal-content">
        <h2>Победа!</h2>
        <p>Уровень пройден!</p>
        <p>Очки: <span id="final-score">0</span></p>
        <p>Комбо: x<span id="final-combo">1</span></p>
        <button class="btn btn-primary" id="next-level-btn">Далее</button>
    </div>
</div>

<!-- LEADERBOARD MODAL -->
<div id="lb-modal" class="modal hidden">
    <div class="modal-content">
        <h2>Лидерборд</h2>
        <div id="lb-list" class="leaderboard"></div>
        <button class="btn btn-primary" id="close-lb">Закрыть</button>
    </div>
</div>

<!-- MODULES -->
<script src="modules/sounds.js"></script>
<script src="modules/leaderboard.js"></script>

<script>
/* ========================================
   MAIN
   ======================================== */
const tg = window.Telegram.WebApp;
tg.expand(); tg.BackButton.hide();

const BOARD_SIZE = 8, GEM_TYPES = 7;
const LEVEL_TARGETS = [1000, 2500, 5000, 10000, 20000];
const LEVEL_MOVES = [25, 22, 20, 18, 15];

const state = {
    board: [], score: 0, moves: 25, level: 1, target: 1000,
    combo: 1, comboMul: 1, selected: null, animating: false,
    premium: false, started: false, name: tg.initDataUnsafe.user?.first_name || "Игрок"
};

const el = {
    loader: document.getElementById('loader'), loaderFill: document.getElementById('loader-fill'),
    container: document.getElementById('game-container'), board: document.getElementById('game-board'),
    score: document.getElementById('score'), moves: document.getElementById('moves'), level: document.getElementById('level'),
    target: document.getElementById('target'), combo: document.getElementById('combo'), progress: document.getElementById('progress-bar'),
    winModal: document.getElementById('win-modal'), finalScore: document.getElementById('final-score'), finalCombo: document.getElementById('final-combo'),
    lbModal: document.getElementById('lb-modal'), lbList: document.getElementById('lb-list'),
    hintBtn: document.getElementById('hint-btn'), premiumBtn: document.getElementById('premium-btn'),
    lbBtn: document.getElementById('leaderboard-btn'), restartBtn: document.getElementById('restart-btn'),
    nextBtn: document.getElementById('next-level-btn'), closeLb: document.getElementById('close-lb')
};

/* ========================================
   GAME LOGIC
   ======================================== */
function createBoard() {
    state.board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
    for (let r = 0; r < BOARD_SIZE; r++)
        for (let c = 0; c < BOARD_SIZE; c++) {
            let type = Math.floor(Math.random() * GEM_TYPES) + 1;
            if (Math.random() < 0.05) type = 'bomb';
            else if (Math.random() < 0.02) type = 'rainbow';
            else if (Math.random() < 0.03) type = 'lightning';
            while (hasMatchAt(r, c, type)) type = Math.floor(Math.random() * GEM_TYPES) + 1;
            state.board[r][c] = type;
        }
    if (!hasPossibleMoves()) createBoard();
}

function hasMatchAt(r, c, t) {
    if (typeof t !== 'number') return false;
    return (c >= 2 && state.board[r][c-1] === t && state.board[r][c-2] === t) ||
           (r >= 2 && state.board[r-1][c] === t && state.board[r-2][c] === t);
}

function renderBoard() {
    el.board.innerHTML = '';
    for (let r = 0; r < BOARD_SIZE; r++)
        for (let c = 0; c < BOARD_SIZE; c++) {
            const type = state.board[r][c];
            if (!type) continue;
            const cell = document.createElement('div');
            cell.className = 'cell'; cell.dataset.r = r; cell.dataset.c = c;
            const gem = document.createElement('div');
            gem.className = typeof type === 'number' ? `gem gem-${type}` : `gem gem-${type}`;
            cell.appendChild(gem);
            el.board.appendChild(cell);
            cell.onclick = () => handleClick(r, c);
        }
}

function handleClick(r, c) {
    if (state.animating || state.moves <= 0) return;
    if (!state.started) state.started = true;

    const gem = { r, c, type: state.board[r][c] };
    if (!state.selected) {
        state.selected = gem;
        selectGem(r, c);
        playSound('click');
    } else if (isNeighbor(state.selected, gem)) {
        state.animating = true;
        playSound('swap');
        swapGems(state.selected, gem).then(ok => {
            if (ok) { state.moves--; updateUI(); checkWin(); }
            state.selected = null; state.animating = false;
        });
    } else {
        clearSelection(); state.selected = gem; selectGem(r, c); playSound('click');
    }
}

function isNeighbor(a, b) { return Math.abs(a.r - b.r) + Math.abs(a.c - b.c) === 1; }

function selectGem(r, c) {
    const gem = document.querySelector(`[data-r="${r}"][data-c="${c}"] .gem`);
    if (gem) gem.classList.add('selected');
}

function clearSelection() {
    document.querySelectorAll('.gem.selected').forEach(g => g.classList.remove('selected'));
}

/* ========================================
   ANIMATIONS & SPECIAL GEMS
   ======================================== */
async function swapGems(g1, g2) {
    const c1 = document.querySelector(`[data-r="${g1.r}"][data-c="${g1.c}"]`);
    const c2 = document.querySelector(`[data-r="${g2.r}"][data-c="${g2.c}"]`);
    const r1 = c1.getBoundingClientRect(), r2 = c2.getBoundingClientRect();
    const dx = r2.left - r1.left, dy = r2.top - r1.top;

    const gem1 = c1.querySelector('.gem'), gem2 = c2.querySelector('.gem');
    gem1.style.position = gem2.style.position = 'fixed';
    gem1.style.left = r1.left + 'px'; gem1.style.top = r1.top + 'px';
    gem2.style.left = r2.left + 'px'; gem2.style.top = r2.top + 'px';
    gem1.style.zIndex = gem2.style.zIndex = 100;

    requestAnimationFrame(() => {
        gem1.style.transform = `translate(${dx}px, ${dy}px)`;
        gem2.style.transform = `translate(${-dx}px, ${-dy}px)`;
    });

    await sleep(300);
    [state.board[g1.r][g1.c], state.board[g2.r][g2.c]] = [state.board[g2.r][g2.c], state.board[g1.r][g1.c]];
    renderBoard();

    const matches = findMatches();
    if (matches.length) {
        await processMatches(matches);
        return true;
    } else {
        [state.board[g1.r][g1.c], state.board[g2.r][g2.c]] = [state.board[g2.r][g2.c], state.board[g1.r][g1.c]];
        renderBoard();
        return false;
    }
}

function findMatches() {
    const matches = [], visited = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(false));
    for (let r = 0; r < BOARD_SIZE; r++)
        for (let c = 0; c < BOARD_SIZE; c++) {
            if (visited[r][c] || !state.board[r][c]) continue;
            const t = state.board[r][c];
            if (t === 'rainbow') {
                matches.push({r, c, len: 1, hor: true, t: 'rainbow'});
                visited[r][c] = true;
                continue;
            }
            let h = 1, v = 1;
            while (c + h < BOARD_SIZE && state.board[r][c + h] === t) h++;
            while (r + v < BOARD_SIZE && state.board[r + v][c] === t) v++;
            if (h >= 3) { matches.push({r, c, len: h, hor: true, t}); for (let i=0;i<h;i++) visited[r][c+i]=true; }
            if (v >= 3) { matches.push({r, c, len: v, hor: false, t}); for (let i=0;i<v;i++) visited[r+i][c]=true; }
        }
    return matches;
}

async function processMatches(matches) {
    state.comboMul += 0.2; state.combo = Math.floor(state.comboMul * 10) / 10;
    let score = 0;
    const toRemove = new Set();

    matches.forEach(m => {
        if (m.t === 'bomb') {
            for (let dr = -1; dr <= 1; dr++)
                for (let dc = -1; dc <= 1; dc++) {
                    const nr = m.r + dr, nc = m.c + dc;
                    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) toRemove.add(`${nr},${nc}`);
                }
            score += 500 * state.combo;
        } else if (m.t === 'rainbow') {
            const color = state.board[m.r][m.c - 1] || state.board[m.r][m.c + 1] || state.board[m.r - 1]?.[m.c] || 1;
            for (let r = 0; r < BOARD_SIZE; r++)
                for (let c = 0; c < BOARD_SIZE; c++)
                    if (state.board[r][c] === color) toRemove.add(`${r},${c}`);
            score += 1000 * state.combo;
        } else if (m.t === 'lightning') {
            for (let r = 0; r < BOARD_SIZE; r++) toRemove.add(`${r},${m.c}`);
            score += 800 * state.combo;
        } else {
            score += m.len * 100 * state.combo;
            for (let i = 0; i < m.len; i++) {
                const r = m.hor ? m.r : m.r + i;
                const c = m.hor ? m.c + i : m.c;
                toRemove.add(`${r},${c}`);
            }
        }
        showCombo(m);
    });

    toRemove.forEach(key => {
        const [r, c] = key.split(',').map(Number);
        explodeGem(r, c);
    });

    state.score += Math.floor(score);
    playSound('explode');
    if (state.combo > 2) playSound('combo');
    await sleep(600);
    await dropGems();
    await spawnGems();
    const next = findMatches();
    if (next.length) await processMatches(next);
    else { state.combo = 1; state.comboMul = 1; }
    updateUI();
    saveProgress();
}

/* Остальные функции (explodeGem, dropGems, spawnGems, etc.) — как в предыдущей версии */
function explodeGem(r, c) { /* ... */ }
function dropGems() { /* ... */ }
function spawnGems() { /* ... */ }
function showCombo(m) { /* ... */ }

/* ========================================
   SAVE & LOAD
   ======================================== */
function saveProgress() {
    const save = { score: state.score, level: state.level, moves: state.moves, name: state.name };
    localStorage.setItem('crystalMatchSave', JSON.stringify(save));
    Leaderboard.add(state.name, state.score);
}

function loadProgress() {
    const saved = localStorage.getItem('crystalMatchSave');
    if (saved) {
        const data = JSON.parse(saved);
        state.score = data.score || 0;
        state.level = data.level || 1;
        state.moves = data.moves || LEVEL_MOVES[state.level-1] || 25;
        state.name = data.name;
    }
    state.target = LEVEL_TARGETS[state.level-1] || state.level * 2000;
}

/* ========================================
   INIT
   ======================================== */
let load = 0;
const interval = setInterval(() => {
    load += 15 + Math.random() * 20;
    el.loaderFill.style.width = Math.min(load, 100) + '%';
    if (load >= 100) {
        clearInterval(interval);
        loadProgress();
        createBoard(); renderBoard(); updateUI();
        el.container.style.display = 'flex';
        el.loader.style.opacity = '0';
        setTimeout(() => el.loader.remove(), 600);
    }
}, 150);

/* События */
el.hintBtn.onclick = showHint;
el.restartBtn.onclick = () => { if (confirm('Начать заново?')) resetGame(); };
el.nextBtn.onclick = nextLevel;
el.lbBtn.onclick = () => { Leaderboard.show(el.lbList); el.lbModal.classList.remove('hidden'); };
el.closeLb.onclick = () => el.lbModal.classList.add('hidden');
el.premiumBtn.onclick = () => tg.showPopup({title:'Премиум', message:'Без рекламы!'}, btn => btn === 'buy' && tg.openInvoice('...'));

</script>
</body>
</html>
